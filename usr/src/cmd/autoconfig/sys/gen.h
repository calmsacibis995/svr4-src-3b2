/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)autoconfig:sys/gen.h	1.5"


/*                                                                               * Driver structure
 *
 * Each driver (or module) existing in /boot is represented by an instance of
 * this structure.  It is built at initialization.  All object files found are
 * referred to as drivers throughout this file -- even though modules (NOTADRV)
 * are sometimes treated specially.
 */

#define MAXCNTL		16			/* maximum number of controllers allowed per device */

struct	driver
	{
        struct driver  *next;
	char	       *name;			/* driver name */
	struct master  *opthdr;			/* optional header from driver object file */
	unsigned char	flag;			/* flags */
	unsigned char	nctl;			/* number of controllers
                                                 *	- actually found in EDT
if a real device driver
                                                 *	- number of INCLUDEs if
a software driver
                                                 *	- constant 1 if a REQuired driver
                                                 */
	unsigned long	int_major;		/* The internal major number generated by self-config */
	unsigned char	otype;			/* object file type */

	/********* end of common elements between struct driver and struct kernel *********/

	unsigned char	ntc_lu;			/* number of logical units across HA,
                                                 * #S expansion
                                                 */

	unsigned long	maj[MAXCNTL];		/* board slots (external major number) of each controller
                                                 *	0000 xxxx - local bus address
                                                 *	0001 xxxx - ELB address
on LBE 14
                                                 *	0010 xxxx - ELB address
on LBE 15
                                                 */
	unsigned char	sys_bits[MAXCNTL];	/* corresponding ELB sys-bits for devices on LBE */
	long		timestamp;		/* f_timdat from file header */
	long		nsyms;			/* number of symbols from filehdr */
	long		symptr;			/* file pointer to symtab */
	short	       *s_index;		/*
                                                 * Since the .text, .data and .bss sections in a
                                                 * common object file are not necessarily in the
                                                 * sequence 1-2-3, this array is used to indirectly
                                                 * reference the shdr[] array using the original
                                                 * section number.
                                                 *	s_index[.text] == 0
                                                 *	s_index[.data] == 1
                                                 *	s_index[.bss] == 2
                                                 */
	SCNHDR		shdr[3];		/* section headers for .text, .data and .bss */
	};



/*
 * Given a major number for a device on a LBE, compute the local bus address
 * (lba) of its LBE and the extended local bus address (elb) of the device
 */
#define LBELBA(m)	(13+((m)>>4))
#define LBEELB(m)	((m)&0x0F)

/*
 * Kernel structure
 *
 * The kernel requiring configuration may contain an optional header built by
 * mkboot(1M).	If so, this optional header is saved with this structure.  This
 * structure is linked to the driver linked-list so that all optional headers
 * may be easily accessed.  In some cases, only the driver optional headers are
 * required -- "driver" is the head of this linked-list.  In other cases, all
 * optional headers must be accessed -- "kernel" is the head of this linked-
 * list.
 *
 * This structure must exactly match struct driver up to the point marked
 * in struct driver.  This is done to allow routines such as eval() and
 * initdata() to be passed a "struct kernel" pointer in place of a "struct
 * driver" pointer.
 */
struct	kernel
	{
	struct driver  *next;
	char	       *name;			/* bootprogram.path */
        struct master  *opthdr;                 /* optional header from kernel object file */
	unsigned char	flag;			/* empty flags field */
	unsigned char	nctl;			/* zero */
	unsigned long	int_major;		/* zero */
	unsigned char	otype;			/* object file type */
	};


struct driver *driver;	 	 	/* head of struct driver linked list */

struct kernel *kernel;	 	 	/* head of object file linked list */


/*
 * Object file types.
 */
#define O_ELF	1
#define O_COFF	2

/*
 * Flags
 */
#define LOAD	0x80		/* load this driver */
#define INEDT	0x40		/* this driver matched in EDT */
#define INCLUDE 0x10		/* /etc/system: include this driver */
#define EXCLUDE 0x08		/* /etc/system: exclude this driver */
#ifdef u3b15
#define ISLBE	0x04		/* this is the entry for the LBE driver */
#endif
#ifdef u3b2
#define ISLBE	0x00		/* 3B2 has no such thing as a LBE */
#endif
#define ISEBUS	0x20		/* extended bus, set for TC's */
/*
 * Is this controller on an extended local bus?
 */
#ifdef u3b15
#define ONLBE(maj)	((maj)&0x30)
#endif
#ifdef u3b2
#define ONLBE(maj)	(FALSE)
#endif

/*
 * Compute external major number for a device on a supported LBE (the LBE must
 * be at local bus address 14 or 15)
 */
#define LBEMAJ(lba,elb) ((((lba)-13)<<4) | (elb))


extern char *last_exp;

extern boolean ignoredt();
extern struct driver   *searchdriver();


extern int		fstypcnt;
extern int		cdevcnt;
extern int		bdevcnt;
extern int		fmodcnt;
extern int		fsincnt;
extern short		nfstyp;
extern int		classcnt;
extern struct cdevsw	*cdevswp;		/* real address */
extern struct bdevsw	*bdevswp;		/* real address */
extern struct fmodsw	*fmodswp;		/* real address */

extern address maxmem;

extern struct param *searchparam();

extern boolean function();


extern void read_and_check();
extern void fwrite_and_check();
extern void seek_and_check();
